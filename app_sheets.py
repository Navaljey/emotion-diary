import json
import os
from datetime import datetime, timedelta
import streamlit as st
from dotenv import load_dotenv, find_dotenv
import google.generativeai as genai
import gspread
from google.oauth2.service_account import Credentials
import matplotlib.pyplot as plt
import matplotlib
import networkx as nx
from io import BytesIO
import numpy as np

# ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï (matplotlib Î∞±ÏóîÎìú ÏÑ§Ï†ï)
matplotlib.use('Agg')
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['axes.unicode_minus'] = False

# PWA HTML
pwa_html = """
<link rel="manifest" href="data:application/json;charset=utf-8,%7B%22name%22%3A%22%EA%B0%90%EC%A0%95%20%EC%9D%BC%EA%B8%B0%22%2C%22short_name%22%3A%22%EA%B0%90%EC%A0%95%EC%9D%BC%EA%B8%B0%22%2C%22description%22%3A%22AI%EA%B0%80%20%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94%20%EA%B0%90%EC%A0%95%20%EC%9D%BC%EA%B8%B0%20%EC%95%B1%22%2C%22start_url%22%3A%22%2F%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23ffffff%22%2C%22theme_color%22%3A%22%23ff6b6b%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%3Bcharset%3Dutf-8%2C%253Csvg%2520xmlns%253D%2522http%253A%252F%252Fwww.w3.org%252F2000%252Fsvg%2522%2520viewBox%253D%25220%25200%2520100%2520100%2522%253E%253Ctext%2520y%253D%2522.9em%2522%2520font-size%253D%252290%2522%253E%25E2%259C%258D%25EF%25B8%258F%253C%252Ftext%253E%253C%252Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">
<style>
@media only screen and (max-width: 768px) {
    .stApp > header { background-color: transparent; }
    .stApp { margin-top: -80px; }
    .main .block-container {
        padding-top: 2rem;
        padding-left: 1rem;
        padding-right: 1rem;
    }
    .stTabs [data-baseweb="tab-list"] { gap: 0.5rem; }
    .stTabs [data-baseweb="tab"] { height: 3rem; padding: 0.5rem 1rem; }
    .stButton > button { height: 3rem; font-size: 1.1rem; }
    [data-testid="metric-container"] {
        background-color: #f0f2f6;
        border: 1px solid #e1e5eb;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
}
@supports (-webkit-touch-callout: none) {
    .stApp {
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
}
</style>
"""

st.set_page_config(
    page_title="Í∞êÏ†ï ÏùºÍ∏∞",
    page_icon="‚úçÔ∏è",
    layout="centered",
    initial_sidebar_state="collapsed",
    menu_items={'Get Help': None, 'Report a bug': None, 'About': "AIÍ∞Ä Î∂ÑÏÑùÌïòÎäî Í∞êÏ†ï ÏùºÍ∏∞ Ïï± üì±"}
)

st.markdown(pwa_html, unsafe_allow_html=True)

_ = load_dotenv(find_dotenv())

# Gemini API ÏÑ§Ï†ï
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY") or st.secrets.get("GEMINI_API_KEY", "")
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    
    st.sidebar.markdown("### üîç ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Gemini Î™®Îç∏")
    available_models = []
    try:
        for m in genai.list_models():
            if 'generateContent' in m.supported_generation_methods:
                available_models.append(m.name)
                st.sidebar.success(f"‚úÖ {m.name}")
        
        if available_models:
            model_name = available_models[0].replace('models/', '')
            st.sidebar.info(f"üìå ÏÇ¨Ïö© Ï§ë: {model_name}")
            model = genai.GenerativeModel(model_name)
        else:
            st.error("‚ùå ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Gemini Î™®Îç∏Ïù¥ ÏóÜÏäµÎãàÎã§.")
            st.stop()
    except Exception as e:
        st.sidebar.error(f"Î™®Îç∏ ÌôïÏù∏ Ïò§Î•ò: {e}")
        model = genai.GenerativeModel('gemini-pro')
else:
    st.error("üîë GEMINI_API_KEYÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    st.stop()

# Google Sheets Ïó∞Í≤∞
@st.cache_resource
def init_google_sheets():
    try:
        scopes = [
            'https://www.googleapis.com/auth/spreadsheets',
            'https://www.googleapis.com/auth/drive'
        ]
        
        credentials_dict = dict(st.secrets["gcp_service_account"])
        credentials = Credentials.from_service_account_info(credentials_dict, scopes=scopes)
        client = gspread.authorize(credentials)
        
        SPREADSHEET_ID = st.secrets["SPREADSHEET_ID"]
        spreadsheet = client.open_by_key(SPREADSHEET_ID)
        
        try:
            diary_ws = spreadsheet.worksheet("diary_data")
        except:
            diary_ws = spreadsheet.add_worksheet(title="diary_data", rows=1000, cols=20)
            diary_ws.update('A1:K1', [[
                'date', 'content', 'keywords', 'total_score', 
                'joy', 'sadness', 'anger', 'anxiety', 'calmness', 
                'message', 'created_at'
            ]])
        
        try:
            expert_ws = spreadsheet.worksheet("expert_advice")
        except:
            expert_ws = spreadsheet.add_worksheet(title="expert_advice", rows=1000, cols=20)
            expert_ws.update('A1:E1', [['date', 'expert_type', 'advice', 'has_content', 'created_at']])
        
        try:
            reminder_ws = spreadsheet.worksheet("reminders")
        except:
            reminder_ws = spreadsheet.add_worksheet(title="reminders", rows=1000, cols=20)
            reminder_ws.update('A1:D1', [['date', 'reminder_type', 'message', 'is_read']])
        
        return diary_ws, expert_ws, reminder_ws
    except Exception as e:
        st.error(f"‚ùå Google Sheets Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        st.stop()

diary_worksheet, expert_worksheet, reminder_worksheet = init_google_sheets()

def load_data_from_sheets():
    try:
        st.sidebar.info("üîÑ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...")
        records = diary_worksheet.get_all_records()
        st.sidebar.success(f"üì• {len(records)}Í∞ú Î†àÏΩîÎìú Î°úÎìúÎê®")
        
        data = {}
        for record in records:
            if record.get('date'):
                date_str = record['date']
                keywords_str = record.get('keywords', '[]')
                try:
                    keywords = json.loads(keywords_str) if isinstance(keywords_str, str) else keywords_str
                except:
                    keywords = keywords_str.split(',') if keywords_str else []
                
                data[date_str] = {
                    'date': date_str,
                    'content': record.get('content', ''),
                    'keywords': keywords,
                    'total_score': float(record.get('total_score', 0)),
                    'joy': int(record.get('joy', 0)),
                    'sadness': int(record.get('sadness', 0)),
                    'anger': int(record.get('anger', 0)),
                    'anxiety': int(record.get('anxiety', 0)),
                    'calmness': int(record.get('calmness', 0)),
                    'message': record.get('message', '')
                }
        
        st.sidebar.success(f"‚úÖ {len(data)}Í∞ú ÏùºÍ∏∞ Î°úÎìú ÏôÑÎ£å")
        return data
    except Exception as e:
        st.sidebar.error(f"Î°úÎìú Ïò§Î•ò: {e}")
        return {}

def save_data_to_sheets(date_str, item_data):
    try:
        st.info(f"üîÑ Ï†ÄÏû• ÏãúÎèÑ: {date_str}")
        all_values = diary_worksheet.get_all_values()
        st.info(f"üìä ÌòÑÏû¨ ÏãúÌä∏ Ìñâ Ïàò: {len(all_values)}")
        
        row_index = None
        for idx, row in enumerate(all_values[1:], start=2):
            if len(row) > 0 and row[0] == date_str:
                row_index = idx
                st.info(f"üìù Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î∞úÍ≤¨: {row_index}Ìñâ")
                break
        
        keywords_str = json.dumps(item_data['keywords'], ensure_ascii=False)
        row_data = [
            str(date_str), str(item_data['content']), str(keywords_str), 
            float(item_data['total_score']),
            int(item_data['joy']), int(item_data['sadness']), int(item_data['anger']),
            int(item_data['anxiety']), int(item_data['calmness']), 
            str(item_data['message']),
            datetime.now().isoformat()
        ]
        
        st.info(f"üíæ Ï†ÄÏû•Ìï† Îç∞Ïù¥ÌÑ∞: {row_data[:3]}...")
        
        if row_index:
            diary_worksheet.update(f'A{row_index}:K{row_index}', [row_data])
            st.success(f"‚úÖ {row_index}Ìñâ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å!")
        else:
            diary_worksheet.append_row(row_data)
            st.success(f"‚úÖ ÏÉà Ìñâ Ï∂îÍ∞Ä ÏôÑÎ£å!")
        
        import time
        time.sleep(1)
        updated_values = diary_worksheet.get_all_values()
        st.success(f"üéâ Ï†ÄÏû• ÌõÑ ÏãúÌä∏ Ìñâ Ïàò: {len(updated_values)}")
        
        return True
    except Exception as e:
        st.error(f"‚ùå Ï†ÄÏû• Ïò§Î•ò: {e}")
        import traceback
        st.error(f"ÏÉÅÏÑ∏:\n```\n{traceback.format_exc()}\n```")
        return False

def delete_data_from_sheets(date_str):
    try:
        all_values = diary_worksheet.get_all_values()
        for idx, row in enumerate(all_values[1:], start=2):
            if row[0] == date_str:
                diary_worksheet.delete_rows(idx)
                return True
        return False
    except Exception as e:
        st.error(f"ÏÇ≠Ï†ú Ïò§Î•ò: {e}")
        return False

def get_latest_data():
    data = load_data_from_sheets()
    items = sorted(data.values(), key=lambda x: x["date"])[-30:]
    return data, items

def save_expert_advice_to_sheets(date_str, expert_type, advice, has_content):
    try:
        all_values = expert_worksheet.get_all_values()
        row_index = None
        
        for idx, row in enumerate(all_values[1:], start=2):
            if len(row) >= 2 and row[0] == date_str and row[1] == expert_type:
                row_index = idx
                break
        
        row_data = [str(date_str), str(expert_type), str(advice), str(has_content), datetime.now().isoformat()]
        
        if row_index:
            expert_worksheet.update(f'A{row_index}:E{row_index}', [row_data])
        else:
            expert_worksheet.append_row(row_data)
        
        return True
    except Exception as e:
        st.error(f"Ï°∞Ïñ∏ Ï†ÄÏû• Ïò§Î•ò: {e}")
        return False

def load_expert_advice_from_sheets(date_str):
    try:
        records = expert_worksheet.get_all_records()
        advice_data = {}
        
        for record in records:
            if record.get('date') == date_str:
                expert_type = record.get('expert_type', '')
                advice_data[expert_type] = {
                    'advice': record.get('advice', ''),
                    'has_content': record.get('has_content', 'False') == 'True',
                    'created_at': record.get('created_at', '')
                }
        
        return advice_data
    except Exception as e:
        return {}

def save_reminder(reminder_type, message):
    try:
        today = datetime.now().strftime("%Y-%m-%d")
        row_data = [today, reminder_type, message, 'False']
        reminder_worksheet.append_row(row_data)
        return True
    except:
        return False

def load_unread_reminders():
    try:
        records = reminder_worksheet.get_all_records()
        unread = []
        for record in records:
            if record.get('is_read') == 'False' or record.get('is_read') == False:
                unread.append(record)
        return unread
    except:
        return []

def mark_reminder_as_read(date, reminder_type):
    try:
        all_values = reminder_worksheet.get_all_values()
        for idx, row in enumerate(all_values[1:], start=2):
            if row[0] == date and row[1] == reminder_type:
                reminder_worksheet.update(f'D{idx}', [['True']])
                break
        return True
    except:
        return False

def check_and_create_reminders(items):
    if not items:
        return
    
    today = datetime.now().date()
    
    # ÎßàÏßÄÎßâ ÏùºÍ∏∞ ÎÇ†Ïßú ÌôïÏù∏
    last_diary_date = datetime.strptime(items[-1]['date'], '%Y-%m-%d').date()
    days_since_last = (today - last_diary_date).days
    
    # 3Ïùº Ïù¥ÏÉÅ ÏùºÍ∏∞Î•º Ïïà ÏçºÏúºÎ©¥ ÏïåÎ¶º
    if days_since_last >= 3:
        message = f"üí≠ ÎßàÏßÄÎßâ ÏùºÍ∏∞Î•º Ïì¥ ÏßÄ {days_since_last}ÏùºÏù¥ ÏßÄÎÇ¨ÏäµÎãàÎã§. Ïò§ÎäòÏùò Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌï¥Î≥¥ÏÑ∏Ïöî!"
        save_reminder("ÏùºÍ∏∞_ÏûëÏÑ±_ÎèÖÎ†§", message)
    
    # Ï£ºÍ∞Ñ Î∂ÑÏÑù ÏïåÎ¶º (Îß§Ï£º ÏùºÏöîÏùº)
    if today.weekday() == 6:  # ÏùºÏöîÏùº
        message = "üìä Ïù¥Î≤à Ï£º Í∞êÏ†ïÏùÑ ÎèåÏïÑÎ≥º ÏãúÍ∞ÑÏûÖÎãàÎã§. Ï†ÑÎ¨∏Í∞Ä Ï°∞Ïñ∏ÏùÑ Î∞õÏïÑÎ≥¥ÏÑ∏Ïöî!"
        save_reminder("Ï£ºÍ∞Ñ_Î∂ÑÏÑù", message)

def create_emotion_flow_chart(items):
    try:
        fig, ax = plt.subplots(figsize=(12, 6))
        
        recent_items = items[-14:] if len(items) >= 14 else items
        dates = [item['date'][-5:] for item in recent_items]
        joy = [item['joy'] for item in recent_items]
        sadness = [item['sadness'] for item in recent_items]
        anger = [item['anger'] for item in recent_items]
        anxiety = [item['anxiety'] for item in recent_items]
        calmness = [item['calmness'] for item in recent_items]
        
        ax.plot(dates, joy, marker='o', label='Joy', color='#FFD700', linewidth=2)
        ax.plot(dates, sadness, marker='o', label='Sadness', color='#4169E1', linewidth=2)
        ax.plot(dates, anger, marker='o', label='Anger', color='#DC143C', linewidth=2)
        ax.plot(dates, anxiety, marker='o', label='Anxiety', color='#FF8C00', linewidth=2)
        ax.plot(dates, calmness, marker='o', label='Calm', color='#32CD32', linewidth=2)
        
        ax.set_xlabel('Date', fontsize=12)
        ax.set_ylabel('Emotion Score', fontsize=12)
        ax.set_title('Emotion Flow Analysis (Recent 2 Weeks)', fontsize=14, fontweight='bold')
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        plt.close()
        
        return buf
    except Exception as e:
        st.error(f"Í∑∏ÎûòÌîÑ ÏÉùÏÑ± Ïò§Î•ò: {e}")
        return None

def create_emotion_network(items):
    try:
        fig, ax = plt.subplots(figsize=(10, 8))
        
        recent_items = items[-30:] if len(items) >= 30 else items
        
        emotions = {
            'Joy': [item['joy'] for item in recent_items],
            'Sadness': [item['sadness'] for item in recent_items],
            'Anger': [item['anger'] for item in recent_items],
            'Anxiety': [item['anxiety'] for item in recent_items],
            'Calm': [item['calmness'] for item in recent_items]
        }
        
        G = nx.Graph()
        emotion_names = list(emotions.keys())
        for emotion in emotion_names:
            G.add_node(emotion)
        
        for i, e1 in enumerate(emotion_names):
            for j, e2 in enumerate(emotion_names):
                if i < j:
                    corr = np.corrcoef(emotions[e1], emotions[e2])[0, 1]
                    if abs(corr) > 0.3:
                        G.add_edge(e1, e2, weight=abs(corr))
        
        pos = nx.spring_layout(G, k=2, iterations=50)
        node_colors = ['#FFD700', '#4169E1', '#DC143C', '#FF8C00', '#32CD32']
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=3000, alpha=0.9, ax=ax)
        
        edges = G.edges()
        weights = [G[u][v]['weight'] for u, v in edges]
        nx.draw_networkx_edges(G, pos, width=[w*5 for w in weights], alpha=0.5, ax=ax)
        nx.draw_networkx_labels(G, pos, font_size=14, font_weight='bold', ax=ax)
        
        ax.set_title('Emotion Correlation Network', fontsize=16, fontweight='bold', pad=20)
        ax.axis('off')
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        plt.close()
        
        return buf
    except Exception as e:
        st.error(f"ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ Ïò§Î•ò: {e}")
        return None

def create_goal_flowchart(items):
    try:
        fig, ax = plt.subplots(figsize=(12, 8))
        
        recent_items = items[-14:] if len(items) >= 14 else items
        dates = [item['date'][-5:] for item in recent_items]
        scores = [item['total_score'] for item in recent_items]
        
        ax.plot(dates, scores, marker='o', color='#1E90FF', linewidth=3, 
                markersize=10, label='Motivation/Energy Level')
        
        avg_score = sum(scores) / len(scores)
        ax.axhline(y=avg_score, color='r', linestyle='--', linewidth=2, 
                   alpha=0.7, label=f'Average: {avg_score:.1f}')
        ax.axhline(y=8, color='g', linestyle='--', linewidth=2, 
                   alpha=0.5, label='Target: 8.0')
        
        ax.fill_between(range(len(dates)), scores, avg_score, 
                        where=[s >= avg_score for s in scores],
                        alpha=0.3, color='green', label='Rising')
        ax.fill_between(range(len(dates)), scores, avg_score,
                        where=[s < avg_score for s in scores],
                        alpha=0.3, color='red', label='Falling')
        
        ax.set_xlabel('Date', fontsize=12)
        ax.set_ylabel('Motivation Level', fontsize=12)
        ax.set_title('Goal Achievement Motivation Analysis', fontsize=14, fontweight='bold')
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)
        ax.set_ylim([0, 10])
        plt.xticks(range(len(dates)), dates, rotation=45)
        plt.tight_layout()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        plt.close()
        
        return buf
    except Exception as e:
        st.error(f"ÌîåÎ°úÏö∞Ï∞®Ìä∏ Ïò§Î•ò: {e}")
        return None

def create_metaphor_prompt(items):
    recent_items = items[-7:] if len(items) >= 7 else items
    emotions_summary = {'joy': 0, 'sadness': 0, 'anger': 0, 'anxiety': 0, 'calmness': 0}
    
    for item in recent_items:
        for emotion in emotions_summary:
            emotions_summary[emotion] += item[emotion]
    
    dominant_emotion = max(emotions_summary, key=emotions_summary.get)
    
    metaphors = {
        'joy': '‚òÄÔ∏è Bright sunshine, blooming flowers, soaring birds',
        'sadness': 'üåßÔ∏è Rainy sky, calm lake, falling leaves',
        'anger': 'üî• Burning flames, storm, rough waves',
        'anxiety': 'üåÄ Dark maze, tangled threads, flickering flame',
        'calmness': 'üåä Calm sea, peaceful forest, sky above clouds'
    }
    
    return f"""
üé® **Your Emotional Metaphor:**

Dominant Emotion: {dominant_emotion.upper()}
Symbol: {metaphors[dominant_emotion]}

This image represents the symbolic expression of emotions from your unconscious.
Through images like {metaphors[dominant_emotion]}, 
you can visualize and understand your inner feelings.
"""

def calc_average_total_score(items):
    return round(sum(item["total_score"] for item in items) / len(items), 2) if items else 0

def calc_char_count(items):
    return sum(len(item["content"]) for item in items)

def calc_keyword_count(items):
    keyword_count = {}
    for item in items:
        for keyword in item["keywords"]:
            keyword_count[keyword] = keyword_count.get(keyword, 0) + 1
    return keyword_count

def gemini_chat(prompt):
    try:
        st.info("ü§ñ Gemini API Ìò∏Ï∂ú Ï§ë...")
        response = model.generate_content(prompt)
        st.success("‚úÖ Gemini API ÏùëÎãµ Î∞õÏùå")
        return response.text
    except Exception as e:
        st.error(f"‚ùå Gemini API Ïò§Î•ò: {e}")
        return None

def sentiment_analysis(content):
    prompt = f"""
    ÏùºÍ∏∞ Í∞êÏ†ï Î∂ÑÏÑù AIÏûÖÎãàÎã§. Îã§Ïùå ÏùºÍ∏∞Î•º Î∂ÑÏÑùÌï¥ JSONÏúºÎ°ú ÎãµÎ≥ÄÌïòÏÑ∏Ïöî.
    ---
    {content}
    ---
    ÌòïÏãù:
    {{
      "keywords": ["ÌÇ§ÏõåÎìú1", "ÌÇ§ÏõåÎìú2", "ÌÇ§ÏõåÎìú3", "ÌÇ§ÏõåÎìú4", "ÌÇ§ÏõåÎìú5"],
      "joy": 0-10,
      "sadness": 0-10,
      "anger": 0-10,
      "anxiety": 0-10,
      "calmness": 0-10
    }}
    """
    
    st.info("üìä Í∞êÏ†ï Î∂ÑÏÑù ÏãúÏûë...")
    try:
        response_text = gemini_chat(prompt)
        if response_text:
            st.info(f"üìù Gemini ÏùëÎãµ (Ï≤òÏùå 100Ïûê): {response_text[:100]}...")
            start = response_text.find('{')
            end = response_text.rfind('}') + 1
            if start >= 0 and end > start:
                json_text = response_text[start:end]
                st.info(f"üîç Ï∂îÏ∂úÎêú JSON: {json_text[:100]}...")
                result = json.loads(json_text)
                st.success("‚úÖ Í∞êÏ†ï Î∂ÑÏÑù ÏôÑÎ£å!")
                return result
    except Exception as e:
        st.error(f"‚ùå Î∂ÑÏÑù Ïò§Î•ò: {e}")
    
    st.warning("‚ö†Ô∏è Í∏∞Î≥∏ Í∞êÏ†ï Ï†êÏàò ÏÇ¨Ïö©")
    return {"keywords": ["ÏùºÍ∏∞", "Ïò§Îäò", "ÌïòÎ£®", "ÏÉùÍ∞Å", "ÎßàÏùå"],
            "joy": 5, "sadness": 3, "anger": 2, "anxiety": 3, "calmness": 4}

def generate_message(today_data, recent_data):
    prompt = f"""
    ÏùºÍ∏∞ Ïï± AIÏûÖÎãàÎã§. Îî∞ÎúªÌïú Î©îÏãúÏßÄÎ•º JSONÏúºÎ°ú ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.
    Ïò§Îäò: {today_data}
    ÏµúÍ∑º: {recent_data}
    ÌòïÏãù: {{"message": "ÏùëÏõê Î©îÏãúÏßÄ üòä"}}
    """
    
    st.info("üíå ÏùëÏõê Î©îÏãúÏßÄ ÏÉùÏÑ± Ï§ë...")
    try:
        response_text = gemini_chat(prompt)
        if response_text:
            start = response_text.find('{')
            end = response_text.rfind('}') + 1
            if start >= 0 and end > start:
                data = json.loads(response_text[start:end])
                st.success("‚úÖ Î©îÏãúÏßÄ ÏÉùÏÑ± ÏôÑÎ£å!")
                return data["message"]
    except:
        pass
    
    return "Ïò§ÎäòÎèÑ ÏùºÍ∏∞Î•º Ïç®Ï£ºÏÖîÏÑú Í∞êÏÇ¨Ìï¥Ïöî! üòä"

def get_expert_advice(expert_type, diary_data):
    sorted_diaries = sorted(diary_data.values(), key=lambda x: x['date'])
    recent_diaries = sorted_diaries[-30:]
    
    diary_summary = []
    for diary in recent_diaries:
        summary = f"ÎÇ†Ïßú: {diary['date']}, ÎÇ¥Ïö©: {diary['content'][:100]}..., Í∞êÏ†ïÏ†êÏàò: {diary['total_score']}"
        diary_summary.append(summary)
    
    diary_text = "\n".join(diary_summary)
    
    expert_prompts = {
        "Ïã¨Î¶¨ÏÉÅÎã¥ÏÇ¨": f"ÎãπÏã†ÏùÄ Í≤ΩÌóò ÎßéÏùÄ Ïã¨Î¶¨ÏÉÅÎã¥ÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏúÑ ÏùºÍ∏∞Îì§ÏùÑ Î∂ÑÏÑùÌïòÏó¨ Í∞êÏ†ï Ìå®ÌÑ¥, Ïä§Ìä∏Î†àÏä§ ÏöîÏù∏, Ïã¨Î¶¨Ï†Å Í±¥Í∞ï Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "Ïû¨Ï†ïÍ¥ÄÎ¶¨ÏÇ¨": f"ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏ Ïû¨Ï†ïÍ¥ÄÎ¶¨ÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏû¨Ï†ï Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ ÏÜåÎπÑ Ìå®ÌÑ¥, Ïû¨Ï†ï Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "Î≥ÄÌò∏ÏÇ¨": f"ÎãπÏã†ÏùÄ Í≤ΩÌóò ÎßéÏùÄ Î≥ÄÌò∏ÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÎ≤ïÏ†Å Î¨∏Ï†úÎ•º Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "ÏùòÏÇ¨": f"ÎãπÏã†ÏùÄ Ï¢ÖÌï©Î≥ëÏõê ÏùòÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÍ±¥Í∞ï Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "ÌîºÎ∂ÄÍ¥ÄÎ¶¨ÏÇ¨": f"ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏ ÌîºÎ∂ÄÍ¥ÄÎ¶¨ÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÌîºÎ∂Ä Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "ÌîºÌä∏ÎãàÏä§ Ìä∏Î†àÏù¥ÎÑà": f"ÎãπÏã†ÏùÄ ÌîºÌä∏ÎãàÏä§ Ìä∏Î†àÏù¥ÎÑàÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏö¥Îèô Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "Ï∞ΩÏóÖ Î≤§Ï≤òÌà¨ÏûêÏûê": f"ÎãπÏã†ÏùÄ ÏÑ±Í≥µÌïú Ï∞ΩÏóÖÍ∞ÄÏûÖÎãàÎã§.\n\n{diary_text}\n\nÎπÑÏ¶àÎãàÏä§ Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}",
        "ÏòàÏà†ÏπòÎ£åÏÇ¨": f"ÎãπÏã†ÏùÄ ÏòàÏà†ÏπòÎ£åÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏ∞ΩÏùòÏ†Å ÌëúÌòÑ ÌôúÎèôÏùÑ Ï†úÏïàÌïòÎäî Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true}}",
        "ÏûÑÏÉÅÏã¨Î¶¨ÏÇ¨": f"ÎãπÏã†ÏùÄ ÏûÑÏÉÅÏã¨Î¶¨ÏÇ¨ÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏ†ïÏã†Í±¥Í∞ï ÏÉÅÌÉúÎ•º ÌèâÍ∞ÄÌïòÎäî Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true}}",
        "Ï°∞ÏßÅÏã¨Î¶¨ Ï†ÑÎ¨∏Í∞Ä": f"ÎãπÏã†ÏùÄ Ï°∞ÏßÅÏã¨Î¶¨ Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§.\n\n{diary_text}\n\nÏßÅÏû• Í¥ÄÎ†® ÎÇ¥Ïö©ÏùÑ Ï∞æÏïÑ Ï°∞Ïñ∏ÏùÑ JSONÏúºÎ°ú: {{\"advice\": \"Ï°∞Ïñ∏\", \"has_content\": true/false}}"
    }
    
    prompt = expert_prompts.get(expert_type, "")
    
    try:
        with st.spinner(f'ü§ñ {expert_type} Î∂ÑÏÑù Ï§ë...'):
            response_text = gemini_chat(prompt)
            if response_text:
                start = response_text.find('{')
                end = response_text.rfind('}') + 1
                if start >= 0 and end > start:
                    json_text = response_text[start:end]
                    result = json.loads(json_text)
                    return result
    except Exception as e:
        st.error(f"Î∂ÑÏÑù Ïò§Î•ò: {e}")
    
    return {"advice": "Ï°∞Ïñ∏ÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.", "has_content": False}

def calc_total_score(item):
    score = (2 * item["joy"] + 1.5 * item["calmness"] - 
             2 * item["sadness"] - 1.5 * item["anxiety"] - 1.5 * item["anger"] + 50)
    return round(score / 8.5, 2)

def compare_periods(items):
    """Í∏∞Í∞ÑÎ≥Ñ ÎπÑÍµê Î∂ÑÏÑù"""
    if len(items) < 14:
        return None
    
    # ÏµúÍ∑º 1Ï£ºÏôÄ Ïù¥Ï†Ñ 1Ï£º ÎπÑÍµê
    recent_week = items[-7:]
    prev_week = items[-14:-7]
    
    def calc_avg(period):
        return {
            'joy': sum(i['joy'] for i in period) / len(period),
            'sadness': sum(i['sadness'] for i in period) / len(period),
            'anger': sum(i['anger'] for i in period) / len(period),
            'anxiety': sum(i['anxiety'] for i in period) / len(period),
            'calmness': sum(i['calmness'] for i in period) / len(period),
            'total': sum(i['total_score'] for i in period) / len(period)
        }
    
    recent_avg = calc_avg(recent_week)
    prev_avg = calc_avg(prev_week)
    
    comparison = {}
    for key in recent_avg:
        diff = recent_avg[key] - prev_avg[key]
        comparison[key] = {
            'recent': recent_avg[key],
            'previous': prev_avg[key],
            'diff': diff,
            'trend': 'ÏÉÅÏäπ' if diff > 0.5 else ('ÌïòÎùΩ' if diff < -0.5 else 'Ïú†ÏßÄ')
        }
    
    return comparison

# Î©îÏù∏ ÌôîÎ©¥
st.title("üì± Í∞êÏ†ï ÏùºÍ∏∞")
st.caption("AIÍ∞Ä Î∂ÑÏÑùÌïòÎäî ÎÇòÎßåÏùò Í∞êÏ†ï Í∏∞Î°ù ‚òÅÔ∏è")

# ÏïåÎ¶º ÌôïÏù∏
unread_reminders = load_unread_reminders()
if unread_reminders:
    st.warning(f"üîî {len(unread_reminders)}Í∞úÏùò ÏÉà ÏïåÎ¶ºÏù¥ ÏûàÏäµÎãàÎã§!")
    with st.expander("ÏïåÎ¶º Î≥¥Í∏∞", expanded=True):
        for reminder in unread_reminders:
            st.info(f"üìÖ {reminder['date']}: {reminder['message']}")
            if st.button(f"ÌôïÏù∏ ÏôÑÎ£å", key=f"read_{reminder['date']}_{reminder['reminder_type']}"):
                mark_reminder_as_read(reminder['date'], reminder['reminder_type'])
                st.rerun()

tab1, tab2, tab3, tab4, tab5 = st.tabs(["‚úçÔ∏è Ïì∞Í∏∞", "üìä ÌÜµÍ≥Ñ", "üìà Í∑∏ÎûòÌîÑ", "üë®‚Äç‚öïÔ∏è Ï†ÑÎ¨∏Í∞Ä Ï°∞Ïñ∏", "üîî ÏïåÎ¶º/ÎπÑÍµê"])

with tab1:
    st.subheader("Ïò§ÎäòÏùò ÎßàÏùå")
    data, items = get_latest_data()
    
    if 'selected_date' not in st.session_state:
        st.session_state.selected_date = datetime.now().date()
    
    selected_date = st.date_input("üìÖ ÎÇ†Ïßú", value=st.session_state.selected_date)
    st.session_state.selected_date = selected_date
    date_str = selected_date.strftime("%Y-%m-%d")
    
    default_content = ""
    total_score = None
    message = None
    diary_exists = date_str in data
    
    if diary_exists:
        default_content = data[date_str]["content"]
        total_score = data[date_str]["total_score"]
        message = data[date_str]["message"]
    
    if data:
        st.success(f"‚òÅÔ∏è {len(data)}Í∞úÏùò ÏùºÍ∏∞Í∞Ä ÌÅ¥ÎùºÏö∞ÎìúÏóê Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏäµÎãàÎã§")
    
    content = st.text_area("üìù Ïò§Îäò ÌïòÎ£®Îäî Ïñ¥Îï†ÎÇòÏöî?", default_content, height=200,
                           placeholder="ÏûêÏú†Î°≠Í≤å ÎßàÏùåÏùÑ Ï†ÅÏñ¥Î≥¥ÏÑ∏Ïöî...")
    
    col1, col2 = st.columns([3, 1])
    with col1:
        save_clicked = st.button("üíæ Ï†ÄÏû•ÌïòÍ∏∞", type="primary", use_container_width=True)
    with col2:
        if diary_exists:
            if st.button("üóëÔ∏è", help="ÏùºÍ∏∞ ÏÇ≠Ï†ú"):
                st.session_state.confirm_delete = date_str
                st.rerun()
        else:
            if st.button("üóëÔ∏è", help="ÎÇ¥Ïö© ÏßÄÏö∞Í∏∞"):
                st.rerun()
    
    if 'confirm_delete' in st.session_state and st.session_state.confirm_delete:
        delete_date = st.session_state.confirm_delete
        st.warning(f"‚ö†Ô∏è {delete_date} ÏùºÍ∏∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?")
        col_yes, col_no = st.columns(2)
        with col_yes:
            if st.button("‚úÖ Ïòà", type="primary", key="yes"):
                if delete_data_from_sheets(delete_date):
                    st.success("üóëÔ∏è ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.")
                del st.session_state.confirm_delete
                st.rerun()
        with col_no:
            if st.button("‚ùå ÏïÑÎãàÏò§", key="no"):
                del st.session_state.confirm_delete
                st.rerun()
        save_clicked = False
    
    if save_clicked:
        if content.strip():
            with st.spinner('ü§ñ AI Î∂ÑÏÑù Ï§ë...'):
                analyzed = sentiment_analysis(content)
                data, items = get_latest_data()
                
                today_data = {
                    "date": date_str, "keywords": analyzed["keywords"],
                    "joy": analyzed["joy"], "sadness": analyzed["sadness"],
                    "anger": analyzed["anger"], "anxiety": analyzed["anxiety"],
                    "calmness": analyzed["calmness"],
                }
                
                recent_data = [{
                    "date": item["date"], "keywords": item["keywords"],
                    "joy": item["joy"], "sadness": item["sadness"],
                    "anger": item["anger"], "anxiety": item["anxiety"],
                    "calmness": item["calmness"],
                } for item in items[-7:]]
                
                message = generate_message(today_data, recent_data)
                
                new_item = {
                    "date": date_str, "content": content, 
                    "keywords": analyzed["keywords"],
                    "total_score": calc_total_score(analyzed),
                    "joy": analyzed["joy"], "sadness": analyzed["sadness"],
                    "anger": analyzed["anger"], "anxiety": analyzed["anxiety"],
                    "calmness": analyzed["calmness"], "message": message,
                }
                
                if save_data_to_sheets(date_str, new_item):
                    st.success("‚úÖ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!")
                    st.balloons()
                    st.rerun()
        else:
            st.warning("‚ö†Ô∏è ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!")
    
    if 'confirm_delete' not in st.session_state:
        st.divider()
        
        if total_score is not None:
            if total_score >= 8:
                emoji, color = "üòÑ", "green"
            elif total_score >= 6:
                emoji, color = "üòä", "blue"
            elif total_score >= 4:
                emoji, color = "üòê", "orange"
            else:
                emoji, color = "üò¢", "red"
            
            st.markdown(f"### üéØ Í∞êÏ†ï Ï†êÏàò: **:{color}[{total_score}/10]** {emoji}")
            
            if date_str in data:
                item = data[date_str]
                st.write("**üé≠ ÏÑ∏Î∂Ä Î∂ÑÏÑù:**")
                cols = st.columns(5)
                emotions = [
                    ("üòÑ", "Í∏∞ÏÅ®", item["joy"]),
                    ("üò¢", "Ïä¨Ìîî", item["sadness"]),
                    ("üò°", "Î∂ÑÎÖ∏", item["anger"]),
                    ("üò∞", "Î∂àÏïà", item["anxiety"]),
                    ("üòå", "ÌèâÏò®", item["calmness"])
                ]
                for i, (e, n, s) in enumerate(emotions):
                    with cols[i]:
                        st.metric(f"{e} {n}", f"{s}")
                
                if message:
                    st.success(f"üíå {message}")
        else:
            st.info("üí° ÏùºÍ∏∞Î•º ÏûëÏÑ±ÌïòÎ©¥ AIÍ∞Ä Î∂ÑÏÑùÌï¥ÎìúÎ†§Ïöî!")

with tab2:
    st.subheader("üìä ÌÜµÍ≥Ñ")
    data, items = get_latest_data()
    
    if not items:
        st.info("üìù Ï≤´ ÏùºÍ∏∞Î•º Ïç®Î≥¥ÏÑ∏Ïöî! ‚ú®")
    else:
        col1, col2 = st.columns(2)
        with col1:
            st.metric("üìà ÌèâÍ∑† Ï†êÏàò", f"{calc_average_total_score(items)}Ï†ê")
            st.metric("‚úèÔ∏è Ï¥ù Í∏ÄÏûê", f"{calc_char_count(items):,}Ïûê")
        with col2:
            st.metric("üìö ÏùºÍ∏∞ Ïàò", f"{len(items)}Í∞ú")
            st.metric("üìÖ ÌôúÎèô Ïõî", f"{len(set([i['date'][:7] for i in items]))}Í∞úÏõî")
        
        st.divider()
        st.write("üè∑Ô∏è **ÌÇ§ÏõåÎìú TOP 10**")
        keywords = calc_keyword_count(items)
        if keywords:
            sorted_kw = sorted(keywords.items(), key=lambda x: x[1], reverse=True)[:10]
            for i, (kw, cnt) in enumerate(sorted_kw):
                if i < 3:
                    st.markdown(f"### {['ü•á','ü•à','ü•â'][i]} **{kw}** `{cnt}Ìöå`")
                else:
                    st.markdown(f"**{i+1}.** {kw} `{cnt}Ìöå`")

with tab3:
    st.subheader("üìà Í∑∏ÎûòÌîÑ")
    data, items = get_latest_data()
    
    if not items:
        st.info("üìù ÏùºÍ∏∞ 2Í∞ú Ïù¥ÏÉÅ ÌïÑÏöî")
    else:
        st.write("**üéØ Í∞êÏ†ï Ï†êÏàò Î≥ÄÌôî**")
        scores = [{"ÎÇ†Ïßú": i["date"][5:], "Ï†êÏàò": i["total_score"]} for i in items[-14:]]
        st.line_chart(scores, x="ÎÇ†Ïßú", y="Ï†êÏàò", height=300)
        
        st.write("**üé≠ Í∞êÏ†ïÎ≥Ñ Î≥ÄÌôî**")
        emotions = [{
            "ÎÇ†Ïßú": i["date"][5:],
            "üòÑÍ∏∞ÏÅ®": i["joy"], "üòåÌèâÏò®": i["calmness"],
            "üò∞Î∂àÏïà": i["anxiety"], "üò¢Ïä¨Ìîî": i["sadness"], "üò°Î∂ÑÎÖ∏": i["anger"],
        } for i in items[-14:]]
        st.area_chart(emotions, x="ÎÇ†Ïßú", 
                     y=["üòÑÍ∏∞ÏÅ®", "üòåÌèâÏò®", "üò∞Î∂àÏïà", "üò¢Ïä¨Ìîî", "üò°Î∂ÑÎÖ∏"], height=300)

with tab4:
    st.subheader("üë®‚Äç‚öïÔ∏è Ï†ÑÎ¨∏Í∞Ä Ï°∞Ïñ∏")
    st.caption("ÏùºÍ∏∞ ÎÇ¥Ïö©ÏùÑ ÏãúÍ∞ÑÏàúÏúºÎ°ú Î∂ÑÏÑùÌïòÏó¨ Ï†ÑÎ¨∏Í∞Ä Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§")
    
    data, items = get_latest_data()
    
    if not items:
        st.info("üìù ÏùºÍ∏∞Î•º ÏûëÏÑ±ÌïòÎ©¥ Ï†ÑÎ¨∏Í∞Ä Ï°∞Ïñ∏ÏùÑ Î∞õÏùÑ Ïàò ÏûàÏäµÎãàÎã§.")
    else:
        st.success(f"üìä ÏµúÍ∑º {len(items)}Í∞úÏùò ÏùºÍ∏∞Î•º Î∂ÑÏÑùÌï©ÎãàÎã§")
        
        st.markdown("### üìÖ Ï°∞Ïñ∏ ÌôïÏù∏ ÎÇ†Ïßú ÏÑ†ÌÉù")
        available_dates = sorted([item['date'] for item in items], reverse=True)
        selected_advice_date = st.selectbox("ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî", options=available_dates, index=0)
        
        saved_advice = load_expert_advice_from_sheets(selected_advice_date)
        if saved_advice:
            st.info(f"üíæ {selected_advice_date}Ïóê Ï†ÄÏû•Îêú Ï°∞Ïñ∏: {len(saved_advice)}Í∞ú")
        
        st.divider()
        
        expert_tabs = st.tabs([
            "üß† Ïã¨Î¶¨ÏÉÅÎã¥", "üí∞ Ïû¨Ï†ï", "‚öñÔ∏è Î≥ÄÌò∏ÏÇ¨", "üè• ÏùòÏÇ¨", "‚ú® ÌîºÎ∂Ä",
            "üí™ ÌîºÌä∏ÎãàÏä§", "üöÄ Ï∞ΩÏóÖ", "üé® ÏòàÏà†", "üß¨ ÏûÑÏÉÅ", "üëî Ï°∞ÏßÅ"
        ])
        
        experts_info = [
            ("Ïã¨Î¶¨ÏÉÅÎã¥ÏÇ¨", "üß†", True),
            ("Ïû¨Ï†ïÍ¥ÄÎ¶¨ÏÇ¨", "üí∞", False),
            ("Î≥ÄÌò∏ÏÇ¨", "‚öñÔ∏è", False),
            ("ÏùòÏÇ¨", "üè•", False),
            ("ÌîºÎ∂ÄÍ¥ÄÎ¶¨ÏÇ¨", "‚ú®", False),
            ("ÌîºÌä∏ÎãàÏä§ Ìä∏Î†àÏù¥ÎÑà", "üí™", False),
            ("Ï∞ΩÏóÖ Î≤§Ï≤òÌà¨ÏûêÏûê", "üöÄ", True),
            ("ÏòàÏà†ÏπòÎ£åÏÇ¨", "üé®", False),
            ("ÏûÑÏÉÅÏã¨Î¶¨ÏÇ¨", "üß¨", True),
            ("Ï°∞ÏßÅÏã¨Î¶¨ Ï†ÑÎ¨∏Í∞Ä", "üëî", False)
        ]
        
        for idx, (expert_name, icon, show_chart) in enumerate(experts_info):
            with expert_tabs[idx]:
                st.markdown(f"### {icon} {expert_name}")
                
                if expert_name in saved_advice:
                    st.success(f"üìã Ï†ÄÏû•Îêú Ï°∞Ïñ∏ ({saved_advice[expert_name]['created_at'][:10]})")
                    st.markdown(saved_advice[expert_name]["advice"])
                    st.divider()
                
                if st.button(f"üí¨ {expert_name} Ï°∞Ïñ∏ Î∞õÍ∏∞", key=f"btn_{expert_name}", use_container_width=True):
                    if show_chart and len(items) >= 2:
                        if expert_name in ["Ïã¨Î¶¨ÏÉÅÎã¥ÏÇ¨", "ÏûÑÏÉÅÏã¨Î¶¨ÏÇ¨"]:
                            flow_chart = create_emotion_flow_chart(items)
                            if flow_chart:
                                st.image(flow_chart, caption="Emotion Flow", use_container_width=True)
                            network_chart = create_emotion_network(items)
                            if network_chart:
                                st.image(network_chart, caption="Emotion Network", use_container_width=True)
                        elif expert_name == "Ï∞ΩÏóÖ Î≤§Ï≤òÌà¨ÏûêÏûê":
                            goal_chart = create_goal_flowchart(items)
                            if goal_chart:
                                st.image(goal_chart, caption="Goal Flow", use_container_width=True)
                    
                    if expert_name == "ÏòàÏà†ÏπòÎ£åÏÇ¨":
                        metaphor = create_metaphor_prompt(items)
                        st.info(metaphor)
                    
                    result = get_expert_advice(expert_name, data)
                    if result.get("has_content"):
                        st.success(f"**{expert_name}Ïùò Ï°∞Ïñ∏:**")
                        st.markdown(result["advice"])
                        save_expert_advice_to_sheets(selected_advice_date, expert_name, 
                                                    result["advice"], result["has_content"])
                        st.success("üíæ Ï°∞Ïñ∏Ïù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§")
                    else:
                        st.info(result["advice"])
        
        st.divider()
        st.warning("‚ö†Ô∏è **Ï£ºÏùò**: AI Ï°∞Ïñ∏ÏùÄ Ï∞∏Í≥†Ïö©ÏûÖÎãàÎã§. Ï†ÑÎ¨∏Í∞Ä ÏÉÅÎã¥Ïù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Î∞òÎìúÏãú Ï†ÑÎ¨∏ÏùòÏôÄ ÏÉÅÎã¥ÌïòÏÑ∏Ïöî.")

with tab5:
    st.subheader("üîî ÏïåÎ¶º Í¥ÄÎ¶¨ & üìä Í∏∞Í∞ÑÎ≥Ñ ÎπÑÍµê")
    data, items = get_latest_data()
    
    st.markdown("### üîî ÏïåÎ¶º ÏÑ§Ï†ï")
    
    # ÏïåÎ¶º Ï≤¥ÌÅ¨ Î∞è ÏÉùÏÑ±
    if items:
        check_and_create_reminders(items)
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìù ÏùºÍ∏∞ ÏûëÏÑ± ÎèÖÎ†§ ÏïåÎ¶º ÏÉùÏÑ±", use_container_width=True):
            save_reminder("ÏàòÎèô_ÎèÖÎ†§", "üí≠ Ïò§ÎäòÏùò Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌï¥Î≥¥ÏÑ∏Ïöî!")
            st.success("ÏïåÎ¶ºÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!")
            st.rerun()
    
    with col2:
        if st.button("üìä Ï£ºÍ∞Ñ Î∂ÑÏÑù ÏïåÎ¶º ÏÉùÏÑ±", use_container_width=True):
            save_reminder("ÏàòÎèô_Ï£ºÍ∞ÑÎ∂ÑÏÑù", "üìä Ïù¥Î≤à Ï£º Í∞êÏ†ïÏùÑ ÎèåÏïÑÎ≥¥ÏÑ∏Ïöî!")
            st.success("ÏïåÎ¶ºÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!")
            st.rerun()
    
    st.divider()
    st.markdown("### üìä Í∏∞Í∞ÑÎ≥Ñ ÎπÑÍµê Î∂ÑÏÑù")
    
    if len(items) >= 14:
        comparison = compare_periods(items)
        
        if comparison:
            st.write("**üìà ÏµúÍ∑º 1Ï£º vs Ïù¥Ï†Ñ 1Ï£º**")
            
            for emotion, data_cmp in comparison.items():
                if emotion == 'total':
                    continue
                
                emotion_names = {
                    'joy': 'üòÑ Í∏∞ÏÅ®',
                    'sadness': 'üò¢ Ïä¨Ìîî',
                    'anger': 'üò° Î∂ÑÎÖ∏',
                    'anxiety': 'üò∞ Î∂àÏïà',
                    'calmness': 'üòå ÌèâÏò®'
                }
                
                trend_icon = "üìà" if data_cmp['trend'] == 'ÏÉÅÏäπ' else ("üìâ" if data_cmp['trend'] == 'ÌïòÎùΩ' else "‚û°Ô∏è")
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric(emotion_names.get(emotion, emotion), 
                             f"{data_cmp['recent']:.1f}",
                             f"{data_cmp['diff']:+.1f}")
                with col2:
                    st.write(f"Ïù¥Ï†Ñ Ï£º: {data_cmp['previous']:.1f}")
                with col3:
                    st.write(f"{trend_icon} {data_cmp['trend']}")
            
            st.divider()
            
            # Ï¢ÖÌï© Î∂ÑÏÑù
            total_trend = comparison['total']['trend']
            if total_trend == 'ÏÉÅÏäπ':
                st.success(f"üéâ Ï¢ÖÌï© Í∞êÏ†ï Ï†êÏàòÍ∞Ä ÏÉÅÏäπÌñàÏäµÎãàÎã§! ({comparison['total']['diff']:+.1f}Ï†ê)")
            elif total_trend == 'ÌïòÎùΩ':
                st.warning(f"üòî Ï¢ÖÌï© Í∞êÏ†ï Ï†êÏàòÍ∞Ä ÌïòÎùΩÌñàÏäµÎãàÎã§. ({comparison['total']['diff']:+.1f}Ï†ê)")
            else:
                st.info(f"‚û°Ô∏è Ï¢ÖÌï© Í∞êÏ†ï Ï†êÏàòÍ∞Ä Ïú†ÏßÄÎêòÍ≥† ÏûàÏäµÎãàÎã§.")
    else:
        st.info("üìù ÎπÑÍµê Î∂ÑÏÑùÏùÑ ÏúÑÌï¥ÏÑúÎäî ÏµúÏÜå 14Í∞úÏùò ÏùºÍ∏∞Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.")

st.divider()
st.markdown("### üíù Îß§Ïùº Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌïòÎ©∞ ÎßàÏùåÏùÑ ÎèåÎ≥¥ÏÑ∏Ïöî!")
st.caption("ü§ñ AI Î∂ÑÏÑù | ‚òÅÔ∏è ÌÅ¥ÎùºÏö∞Îìú Ï†ÄÏû• | üîî ÏïåÎ¶º Í∏∞Îä•")

